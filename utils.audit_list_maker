#!/bin/bash
#: Title		:utils.audit_list_maker
#: Date			:2019-07-05
#: Author		:adebayo10k
#: Version		:1.0
#: Description	:create independently stored reference listings of the media files
#: Description	:on a drive when the backup of those files is not really justified.
#: Description	:backup reacquire recreate 
#: Options		:
##
echo "USAGE: $(basename $0) <PROD|DEV>"  
## at command line:~# 
##
#######################################################################

# Except when called by a launcher script this script is the sole entry point into program,
# and thus the parent process - so we set any environment variables here.

## EXIT CODES:
E_UNEXPECTED_BRANCH_ENTERED=10
E_OUT_OF_BOUNDS_BRANCH_ENTERED=11
E_INCORRECT_NUMBER_OF_ARGS=12
E_UNEXPECTED_ARG_VALUE=13
E_REQUIRED_FILE_NOT_FOUND=20
E_UNKNOWN_RUN_MODE=30
E_UNKNOWN_EXECUTION_MODE=31

export E_UNEXPECTED_BRANCH_ENTERED
export E_OUT_OF_BOUNDS_BRANCH_ENTERED
export E_INCORRECT_NUMBER_OF_ARGS
export E_UNEXPECTED_ARG_VALUE
export E_REQUIRED_FILE_NOT_FOUND
export E_UNKNOWN_RUN_MODE
export E_UNKNOWN_EXECUTION_MODE

#################################

# TEST COMMAND LINE ARGS
if [ $# -ne 1 ]
then
	echo "Incorrect number of command line args. Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit E_INCORRECT_NUMBER_OF_ARGS
fi

# if ! [[ "${1}" = 'DEV' -o "${1}" = 'PROD' ]]
if ! [[ "${1}" = 'DEV' || "${1}" = 'PROD' ]] 
then
	echo "Incorrect command line arg.  Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit E_UNEXPECTED_ARG_VALUE
fi

#################################

# SET PROGRAM RUN MODE:
# passed in from command line, this is set to:
# DEV during developemnt. We work on controlled, sample configuration and input data
# PROD when working on real data using real configuration settings
RUN_MODE=$1 
export RUN_MODE

#################################

# TEST: change the following to handle changed file path format:
# file paths to conform to unix standard:
# no leading / for relative paths
# trailing / for directories
# 
echo "Full path to this script: $0" && echo

## remove from end of full path: a directory delimiter and the basename
echo "Current base directory of this script: ${0%'/'"$(basename $0)"}" 
script_root_dir="${0%'/'"$(basename $0)"}"
echo "Script root directory set to: $script_root_dir"
export script_root_dir

echo;echo

## remove from end of full path: just the basename, leaving trailing /
echo "Current base directory of this script: ${0%"$(basename $0)"}" 
script_root_dir="${0%"$(basename $0)"}"
echo "Script root directory set to: $script_root_dir" && echo

export script_root_dir

#################################

# SET PATH TO CONFIGURATION FILE:
# set a default location for the config file
# during development we'll put:
# - an untracked development version outside $script_root_dir (perhaps in it's parent dir)
# - a tracked sanitised version in $script_root_dir
# during service we'll put the config file in an /etc directory:
# 
# config sanitiser script located outside $script_root_dir ?

config_file_basename=audit_config
echo "Our configuration filename is set to: $config_file_basename" && echo

## full path to the directory in which the configuration file is located.
# ad-hoc to keep our stuff hidden for now. Later hope to just hard code this.
config_file_root_dir="$(cd $script_root_dir; cd ../; pwd)" ## returns with no trailing /
echo "Our configuration file sits in: $config_file_root_dir" && echo

full_path_to_config_file="${config_file_root_dir}/${config_file_basename}"
echo "The full path to our configuration file is: $full_path_to_config_file" && echo

# TEST THAT CONFIGURATION FILE EXISTS IN THE DEFAULT LOCATION AND IS ACCESSIBLE.
# testing 'all in one' for now assuming no part will fail
if [ -d "$config_file_root_dir" ] 2>/dev/null && \
cd "$config_file_root_dir" 2>/dev/null && \
[ -f "$full_path_to_config_file" ] 2>/dev/null
then
	# configuration file found and accessible
	echo "Configuration file found ok" && echo
	else
	# -> exit due to failure of any of the above tests:
	echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
	exit E_REQUIRED_FILE_NOT_FOUND
fi

##########################################################################################################

function test_line_content_valid
# test that the line is either a comment, empty/blank or string of valid format
{
	line="${1}"

	if [[ "$line" == "#"* ]] # line is a comment
	then
		echo "This line was found to be a comment:"
		#echo "$line"
	elif [[ "$line" =~ [[:blank:]] || "$line" == "" ]] # line empty or contains only spaces or tab characters
	then
		echo "Blank line"
	elif [[ "$line" =~ [[:alnum:]] ]] # line is a string (not commented)
	then

		echo -n "Alphanumeric string  :  "
		if [[ "$line" == *"=" ]]
		then
			echo "Variable Alpha string="
		##  	
		elif [[ "$line" =~ ^.*/.*$ ]]	# match the file path pattern TODO: find a better regex
		then
			echo "Value Alpha string/"
		else
			echo "Failsafe : Couldn't match the Alphanum string"
			exit 1
		fi

	else
		echo "None of the above"
		exit 1
	fi

}

##########################################################################################################

# TEST THAT CONFIGURATION FILE FORMAT IS VALID
while read lineIn
do

	test_line_content_valid "$lineIn" 

done < "$full_path_to_config_file" 

echo "exit code after line tests: $?" && echo

## if $? -eq 0 ...

# if tests passed, configuration file is accepted and used from here on
echo "we can use this configuration file"
export config_file_basename
export config_file_root_dir
export full_path_to_config_file

##########################################################################################################

function get_audit_list_storage_directory_config
{
	# ignore empty lines and comment lines
	# sanitise values
	# - trim leading and trailing space characters
	# - trim leading / for relative paths
	# - trim trailing / for all paths
	# test that directories exist and are accessible

	keyword="audit_list_storage_directory="

	while read lineIn
	do

		test_line_content_valid "$lineIn" 

	done < "$full_path_to_config_file" 

}

##########################################################################################################

function get_source_directory_config
{
	keyword="source_directory="

}

##########################################################################################################

function get_directories_to_ignore_config
{
	keyword="directories_to_ignore="

}

##########################################################################################################

function get_secret_content_directories_config
{
	keyword="secret_content_directories="

}

##########################################################################################################

# IMPORT CONFIGURATION INTO VARIABLES

# explicitly declaring variables to make code bit more robust - move to top
audit_list_storage_directory="" # single directory in which....
source_directory="" # single directory from which....
declare -a directories_to_ignore # set of one or more directories...
declare -a secret_content_directories # set of one or more directories...

get_audit_list_storage_directory_config
get_source_directory_config
get_directories_to_ignore_config
get_secret_content_directories_config

# debug printouts:
echo "audit_list_storage_directory variable now set to: $audit_list_storage_directory" && echo
echo "source_directory variable now set to: $source_directory" && echo
echo "directories_to_ignore list now set to:"
for dir_path in "${directories_to_ignore[@]}"
do
	echo "$dir_path"
done
echo
echo "secret_content_directories list now set to:"
for dir_path in "${secret_content_directories[@]}"
do
	echo "$dir_path"
done

#unset directories_to_ignore
# multi-dim arrays not poss - find another way
#declare -a absolute_path_dirs=($audit_list_storage_directory $source_directory)
#declare -a relative_path_dirs=($directories_to_ignore $secret_content_directories)

#################################

# WRITE SOURCE MEDIA FILENAMES TO THE STORAGE LOCATION

# the designated storage directory must already exist - it won't be created by this script.


#################################

echo "exit code: $?" && exit 



