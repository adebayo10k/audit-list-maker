#!/bin/bash
#: Title		:utils.audit_list_maker
#: Date			:2019-07-05
#: Author		:adebayo10k
#: Version		:1.0
#: Description	:create independently stored reference listings of the media files
#: Description	:on a drive when the backup of those files is not really justified.
#: Description	:backup reacquire recreate 
#: Options		:
##
echo "USAGE: $(basename $0) <PROD|DEV>"  
## at command line:~# 
##

#######################################################################

# SET PROGRAM RUN MODE:
# passed in from command line, this is set to:
# DEV during developemnt. We work on controlled, sample configuration and input data
# PROD when working on real data using real configuration settings
RUN_MODE=$1 
export RUN_MODE

#######################################################################

## EXIT CODES:
E_UNEXPECTED_BRANCH_ENTERED=10
E_OUT_OF_BOUNDS_BRANCH_ENTERED=11
E_INCORRECT_NUMBER_OF_ARGS=12
E_UNEXPECTED_ARG_VALUE=13
E_REQUIRED_FILE_NOT_FOUND=20
E_UNKNOWN_RUN_MODE=30
E_UNKNOWN_EXECUTION_MODE=31

export E_UNEXPECTED_BRANCH_ENTERED
export E_OUT_OF_BOUNDS_BRANCH_ENTERED
export E_INCORRECT_NUMBER_OF_ARGS
export E_UNEXPECTED_ARG_VALUE
export E_REQUIRED_FILE_NOT_FOUND
export E_UNKNOWN_RUN_MODE
export E_UNKNOWN_EXECUTION_MODE

#######################################################################

# GLOBAL VARIABLE DECLARATIONS:
line_type="" # global...
test_line="" # global...
config_file_fullpath= # a full path to a file

# explicitly declaring variables to make code bit more robust - move to top
destination_holding_dir_fullpath="" # single directory in which....# a full path to directory
source_holding_dir_fullpath="" # single directory from which....# a full path to directory
declare -a directories_to_ignore=() # set of one or more relative path directories...
declare -a secret_content_directories=() # set of one or more relative path directories...

abs_filepath_regex='^(/{1}[A-Za-z0-9\._-~]+)+$' # absolute file path
all_filepath_regex='^(/?[A-Za-z0-9\._-~]+)+$' # both relative and absolute file path

declare -a file_fullpaths_to_encrypt=() # set of files created from secret directory data
string_to_send=""

#script_dir_fullpath ## a full path to directory
#test_dir_fullpath ## a full path to directory [[[ LOCAL CONTROL IN 1 FUNC ]]]
#user_config_file_fullpath # a full path to a file
#config_file_name # a filename
#config_dir_fullpath # a full path to directory

#dir_name # a directory name [[[ LOCAL CONTROL IN 1 MAIN PLACE ]]]
#test_dir_fullpath # a full path to directory [[[ LOCAL CONTROL IN 1 FUNC ]]]
#ignore_dir_name # a directory name
#source_input_dir_fullpath # a full path to directory
#source_input_dir_name # a directory name
#destination_output_file_name # a filename date augmented 
#destination_output_file_fullpath # # a full path to a file (.. to destination_output_file_name)



#######################################################################

# TEST COMMAND LINE ARGS
if [ $# -ne 1 ]
then
	echo "Incorrect number of command line args. Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit $E_INCORRECT_NUMBER_OF_ARGS
fi

# if ! [[ "${1}" = 'DEV' -o "${1}" = 'PROD' ]]
if ! [[ "${1}" = 'DEV' || "${1}" = 'PROD' ]] 
then
	echo "Incorrect command line arg.  Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit $E_UNEXPECTED_ARG_VALUE
fi

#######################################################################

# SET THE SCRIPT ROOT DIRECTORY (IN WHICH THIS SCRIPT CURRENTLY FINDS ITSELF)
# 
echo "Full path to this script: $0" && echo

## remove from end of full path: a directory delimiter and the basename
## TODO: UNLESS SCRIPT 'SOMEHOW' SITS IN THE ROOT DIRECTORY, IN WHICH CASE WE'D JUST REMOVE "$(basename $0)"
script_dir_fullpath="${0%'/'"$(basename $0)"}"
echo "Script root directory set to: $script_dir_fullpath"
export script_dir_fullpath

echo;echo

#######################################################################
# USED GENERALLY TO TEST EXISTENCE AND ACCESSIBILITY OF A DIRECTORY
function test_directory_accessible
{
echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	test_dir_fullpath="$1"

	if [ -d "$test_dir_fullpath" ] && cd "$test_dir_fullpath" 2>/dev/null
	then
		# directory file found and accessible
		echo "directory "$test_dir_fullpath" found and accessed ok" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
		exit $E_REQUIRED_FILE_NOT_FOUND
	fi

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

#######################################################################
#######################################################################

echo
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo "STARTING THE 'SET PATH TO CONFIGURATION FILE' PHASE"
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo

# SET PATH TO CONFIGURATION FILE:

# during service we'll put the config file in an /etc directory:
# 

## TODO: USE OPTION MENU, THE $REPLY VARIABLE... FOR BETTER INTERACTION
function get_config_file_to_use
{
	## 
	## 
	echo
	echo ">>>   Firstly, which configuration file will we be using today...?   :::"
	echo
	echo "Enter the full, absolute path (with leading /), or just press Enter to accept the default"
	echo
	echo "    "

	read user_config_file_fullpath
}

echo "	==================================================================="
echo "	||               Welcome to the AUDIT LIST MAKER                  ||  author: adebayo10k"  
echo "	==================================================================="
echo
#echo " Type q to quit."
echo #&& sleep 1

get_config_file_to_use

config_file_fullpath=${user_config_file_fullpath:-"default_config_file"}

if [ "$config_file_fullpath" == "default_config_file" ]
then

	config_file_name="audit_config"
	echo "Our configuration filename is set to: $config_file_name" && echo

	#config_dir_fullpath="$(cd $script_dir_fullpath; cd ../; pwd)" ## returns with no trailing /
	config_dir_fullpath="/etc"
	echo "Our configuration file sits in: $config_dir_fullpath" && echo

	config_file_fullpath="${config_dir_fullpath}/${config_file_name}"
	echo "The full path to our configuration file is: $config_file_fullpath" && echo

elif [ "$config_file_fullpath" == "$user_config_file_fullpath" ]
then

	config_dir_fullpath="${user_config_file_fullpath%'/'*}" # also, try [[:alphanum:]] or [A-Za-z0-9_-]
	echo "Our configuration file sits in: $config_dir_fullpath" && echo

	config_file_fullpath="$user_config_file_fullpath"
	echo "The full path to our configuration file is: $config_file_fullpath" && echo
	#exit 0

else
	echo "path to configuration file set to: $config_file_fullpath so I QUIT"
	echo "failsafe exit" && sleep 2
	echo "Exiting from function \"${FUNCNAME[0]}\" in script $(basename $0)"
	exit $E_OUT_OF_BOUNDS_BRANCH_ENTERED

fi	

# TEST THAT CONFIGURATION FILE EXISTS IN THE DEFAULT LOCATION AND IS ACCESSIBLE.
test_directory_accessible "$config_dir_fullpath"

# test for expected file type (regular) and read permission
if [ -f "$config_file_fullpath" ] && [ -r "$config_file_fullpath" ]
then
	# configuration file found and accessible
	echo "Configuration file found ok" && echo
else
	# -> exit due to failure of any of the above tests:
	echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
	exit $E_REQUIRED_FILE_NOT_FOUND
fi

##########################################################################################################
# TESTS WHETHER THE LINE IS OF EITHER VALID comment, empty/blank OR string (variable or value) TYPE,
# SETS THE GLOBAL line_type AND test_line variableS.
function test_and_set_line_type
{

#echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	# TODO: ADD ANOTHER CONFIG FILE VALIDATION TEST:
	# TEST THAT THE LINE FOLLOWING A VARIABLE= ALPHANUM STRING MUST BE A VALUE/ ALPHANUM STRING, ELSE FAIL
	test_line="${1}"
	line_type=""

	#debug printouts:
	#echo "$test_line"

	if [[ "$test_line" == "#"* ]] # line is a comment
	then
		line_type="comment"
		#echo "line_type set to: $line_type"
	elif [[ "$test_line" =~ [[:blank:]] || "$test_line" == "" ]] # line empty or contains only spaces or tab characters
	then
		line_type="empty"
		#echo "line_type set to: $line_type"
	elif [[ "$test_line" =~ [[:alnum:]] ]] # line is a string (not commented)
	then
		echo -n "Alphanumeric string  :  "
		if [[ "$test_line" == *"=" ]]
		then
			line_type="variable_string"
			echo "line_type set to: "$line_type" for "$test_line""
		elif [[ "$test_line" =~ $all_filepath_regex ]]	#
		then
			line_type="value_string"
			echo "line_type set to: "$line_type" for "$test_line""
		else
			echo "Failsafe : Couldn't match the Alphanum string"
			echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
			exit $E_UNEXPECTED_BRANCH_ENTERED
		fi

	else
		echo "Failsafe : Couldn't match this line with ANY line type!"
		echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
		exit $E_UNEXPECTED_BRANCH_ENTERED
	fi

#echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################

# TEST WHETHER THE CONFIGURATION FILE FORMAT IS VALID
while read lineIn
do
	test_and_set_line_type "$lineIn" 

done < "$config_file_fullpath" 

echo "exit code after line tests: $?" && echo

## TODO: if $? -eq 0 ... ANY POINT IN BRINGING BACK A RETURN CODE?

# if tests passed, configuration file is accepted and used from here on
echo "we can use this configuration file" && echo
export config_file_name
export config_dir_fullpath
export config_file_fullpath

##########################################################################################################
##########################################################################################################
# FINAL OPERATION ON VALUE, SO GLOBAL test_line SET HERE. RENAME CONCEPTUALLY DIFFERENT test_line NAMESAKES
function sanitise_absolute_path_value ##
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	# sanitise values
	# - trim leading and trailing space characters
	# - trim trailing / for all paths
	test_line="${1}"
	echo "test line on entering "${FUNCNAME[0]}" is: $test_line" && echo

	# TRIM TRAILING AND LEADING SPACES AND TABS
	test_line=${test_line%%[[:blank:]]}
	test_line=${test_line##[[:blank:]]}

	# TRIM TRAILING / FOR ABSOLUTE PATHS:
	test_line=${test_line%'/'}
	#test_line=${test_line%\/}

	echo "test line after trim cleanups in "${FUNCNAME[0]}" is: $test_line" && echo

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}


##########################################################################################################
# FINAL OPERATION ON VALUE, SO GLOBAL test_line SET HERE...
function sanitise_relative_path_value
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	# sanitise values
	# - trim leading and trailing space characters
	# - trim leading / for relative paths
	# - trim trailing / for all paths
	test_line="${1}"
	echo "test line on entering "${FUNCNAME[0]}" is: $test_line" && echo

	# TRIM TRAILING AND LEADING SPACES AND TABS
	test_line=${test_line%%[[:blank:]]}
	test_line=${test_line##[[:blank:]]}

	# TRIM LEADING AND TRAILING / FOR RELATIVE PATHS:
	test_line=${test_line%'/'}
	#test_line=${test_line%\/}
	test_line=${test_line##'/'}
	#test_line=${test_line##\/}

	echo "test line after trim cleanups in "${FUNCNAME[0]}" is: $test_line" && echo

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################
##########################################################################################################
## VARIABLE 1:
# TODO: LATER - COULD THESE TWO FUNCTIONS FOR VARIABLES 1 AND 2 BE CONSOLIDATED INTO ONE FOR ABSOLUTED PATH VALUES?
# ...WITH A keyword ARRAY FOR LOOPED THOUGH?
function get_destination_holding_dir_fullpath_config
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	keyword="destination_holding_dir_fullpath="
	line_type=""
	value_collection="OFF"

	while read lineIn
	do

		test_and_set_line_type "$lineIn" # interesting for the line FOLLOWING that keyword find

		if [[ $value_collection == "ON" && $line_type == "value_string" ]]
		then
			sanitise_absolute_path_value "$lineIn"
			echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
			echo "test_line has the value: $test_line"
			echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
			set -- $test_line # using 'set' to get test_line out of this subprocess into a positional parameter ($1)

		elif [[ $value_collection == "ON" && $line_type != "value_string" ]] # last value has been collected for destination_holding_dir_fullpath
		then
			value_collection="OFF" # just because..
			break # end this while loop, as last value has been collected for destination_holding_dir_fullpath
		else
			# value collection must be OFF
			:
		fi
		
		
		# switch value collection ON for the NEXT line read
		if [[ "$lineIn" == "$keyword" ]]
		then
			value_collection="ON"
		fi

	done < "$config_file_fullpath"

	# ASSIGN
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	echo "test_line has the value: $1"
	echo "destination_holding_dir_fullpath has the value: $destination_holding_dir_fullpath"
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"

	destination_holding_dir_fullpath="$1" # test_line just set globally in sanitise_absolute_path_value function
	set -- # unset that positional parameter we used to get test_line out of that while read subprocess
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	echo "test_line (AFTER set --) has the value: $1"
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"


echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################
## VARIABLE 2:
function get_source_holding_dir_fullpath_config
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	keyword="source_holding_dir_fullpath="
	## ACCESS TO RELATIVE DIRECTORIES CAN ONLY BE TESTED ONCE source_holding_dir_fullpath
	# HAS BEEN TESTED OK AND VARIABLE ASSIGNED
	line_type=""
	value_collection="OFF"

	while read lineIn
	do

		test_and_set_line_type "$lineIn" # interesting for the line FOLLOWING that keyword find

		if [[ $value_collection == "ON" && $line_type == "value_string" ]]
		then
			sanitise_absolute_path_value "$lineIn"
			set -- $test_line # 

		elif [[ $value_collection == "ON" && $line_type != "value_string" ]] # last value has been collected for destination_holding_dir_fullpath
		then
			value_collection="OFF" # just because..
			break # end this while loop, as last value has been collected for destination_holding_dir_fullpath
		else
			# value collection must be OFF
			:
		fi
		
		
		# switch value collection ON for the NEXT line read
		if [[ "$lineIn" == "$keyword" ]]
		then
			value_collection="ON"
		fi

	done < "$config_file_fullpath"


	# ASSIGN 
	source_holding_dir_fullpath=$1 # test_line was just set globally in sanitise_absolute_path_value function
	set -- # unset that positional parameter we used to get test_line out of that while read subprocess

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################
## VARIABLE 3:
function get_directories_to_ignore_config
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	keyword="directories_to_ignore="

	# NOW MULTIPLE LINE VALUES ASSIGNED TO ARRAY ELEMENT, SO BIT DIFFERENCE LOGIC
	line_type=""
	value_collection="OFF"
	# unset path_list?
	declare -a path_list=() # local array to store one or more sanitised relative paths

	while read lineIn
	do

		test_and_set_line_type "$lineIn" # interesting for the line FOLLOWING that keyword find

		if [[ "$value_collection" == "ON" && "$line_type" == "value_string" ]]
		then
			
			sanitise_relative_path_value "$lineIn"
			path_list+=("${test_line}")
			# Not sure why we CAN access test_line here, when we had to use 'set' in the other functions?!?
			# Seems to work ok, so no complaining.
			
		elif [[ "$value_collection" == "ON" && "$line_type" != "value_string" ]] # last value has been collected for ...
		then
			
			value_collection="OFF" # just because..
			break # end this while loop, as last value has been collected for ....y
		else
			# value collection must be OFF
			:
		fi
		
		
		# switch value collection ON for the NEXT line read
		if [[ "$lineIn" == "$keyword" ]]
		then
			value_collection="ON"
		fi
		
	done < "$config_file_fullpath"

	## debug7..
	echo && echo "The values in the path_list array just before it's cloned by the directories_to_ignore array:"
	for value in "${path_list[@]}"
	do
		echo -n "$value "

	done

	# ASSIGN THE LOCAL ARRAY BY CLONING
	directories_to_ignore=("${path_list[@]}")

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################
## VARIABLE 4:
function get_secret_content_directories_config
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	keyword="secret_content_directories="

	# NOW MULTIPLE LINE VALUES ASSIGNED TO ARRAY ELEMENT, SO BIT DIFFERENCE LOGIC
	line_type=""
	value_collection="OFF"
	declare -a path_list=() # local array to store one or more sanitised relative paths

	while read lineIn
	do

		test_and_set_line_type "$lineIn" # interesting for the line FOLLOWING that keyword find

		if [[ $value_collection == "ON" && $line_type == "value_string" ]]
		then
			sanitise_relative_path_value "$lineIn"
			path_list+=( "${test_line}" )
			# Not sure why we CAN access test_line here, when we had to use 'set' in the other functions?!?
			# Seems to work ok, so no complaining.

		elif [[ $value_collection == "ON" && $line_type != "value_string" ]] # last value has been collected for ...
		then
			value_collection="OFF" # just because..
			break # end this while loop, as last value has been collected for ...
		else
			# value collection must be OFF
			:
		fi
		
		
		# switch value collection ON for the NEXT line read
		if [[ "$lineIn" == "$keyword" ]]
		then
			value_collection="ON"
		fi

	done < "$config_file_fullpath"

	# ASSIGN THE LOCAL ARRAY BY CLONING
	secret_content_directories=("${path_list[@]}")

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################

# IMPORT CONFIGURATION INTO VARIABLES

echo
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo "STARTING THE 'IMPORT CONFIGURATION INTO VARIABLES' PHASE"
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo


#TODO: ALL THESE CAN BE DONE IN ONE FUNCTION LATER?, BUT KEEP IT SIMPLE FOR NOW
# SINGLE FUNCTION WOULD STORE EACH keyword IN AN ARRAY, WHICH WE'D LOOP THROUGH FOR EACH LINE READ
get_destination_holding_dir_fullpath_config
get_source_holding_dir_fullpath_config
get_directories_to_ignore_config
get_secret_content_directories_config

# NOW DO ALL THE DIRECTORY ACCESS TESTS FOR IMPORTED PATH VALUES HERE.
# REMEMBER THAT ORDER IMPORTANT, AS RELATIVE PATHS DEPEND ON ABSOLUTE.
# debug printouts:
echo
echo "FINALLY, destination_holding_dir_fullpath variable now set to: $destination_holding_dir_fullpath" && echo
test_directory_accessible "${destination_holding_dir_fullpath}"

echo "FINALLY, source_holding_dir_fullpath variable now set to: $source_holding_dir_fullpath" && echo
test_directory_accessible "$source_holding_dir_fullpath"

# DO WE REALLY NEED TO TEST ACCESS TO THE DIRECTORIES WE'RE GOING TO IGNORE????
for dir_name in "${directories_to_ignore[@]}"
do
	echo -n "FINALLY, directories_to_ignore list ITEM now set to:"
	echo "$dir_name"
	test_directory_accessible "${source_holding_dir_fullpath}/$dir_name"
done

echo

for dir_name in "${secret_content_directories[@]}"
do
	echo -n "FINALLY, secret_content_directories list ITEM now set to:"
	echo "$dir_name"
	test_directory_accessible "${source_holding_dir_fullpath}/$dir_name"
done

##########################################################################################################
##########################################################################################################

# WRITE SOURCE MEDIA FILENAMES TO THE STORAGE LOCATION
# the designated storage directory must already exist - it won't be created by this script.

# TODO: if wc -l destination_output_file_fullpath >= 12000; then continue writing to output_file2

# 
#date=$(date +'%T')
#date=$(date +'%F')
#date=$(date +'%F@%T')

##########################################################################################################
# return a match for dir paths in the secret_dir_name array, set a result and return immediately
function test_for_secret_dir
{
	test_dir_fullpath="$1"

	for secret_dir_name in "${secret_content_directories[@]}"
	do
		echo
		echo "INSIDE THE SECRET TEST FUNCTION:"
		echo "test_dir_fullpath : $test_dir_fullpath"
		echo "secret_dir_name : $secret_dir_name"

		if [[ "$test_dir_fullpath" == "${source_holding_dir_fullpath}/$secret_dir_name" ]]
		then
			echo "TEST FOUND A MATCH TO LABEL SECRET!!!!!!!!!!!!!!!!!############0000000000 $test_dir_fullpath "
			result=0 # found, so break out of for loop
			return "$result" # found, so break out of for loop
		else 
			result=1
		fi
	done

	return "$result" # returns 1 for failing to find a match

}

##########################################################################################################
# return a match for dir paths in the directories_to_ignore array, set a result and return (break out) immediately
function test_for_ignore_dir
{
	test_dir_fullpath="$1"

	for ignore_dir_name in "${directories_to_ignore[@]}"
	do
		echo
		echo "INSIDE THE IGNORE TEST FUNCTION:"
		echo "test_dir_fullpath : $test_dir_fullpath"
		echo "ignore_dir_name : $ignore_dir_name"

		if [[ "$test_dir_fullpath" == "${source_holding_dir_fullpath}/$ignore_dir_name" ]]
		then
			echo "TEST FOUND A MATCH TO IGNORE!!!!!!!!!!!!!!!!!############0000000000 $test_dir_fullpath "
			result=0 # found, so break out of for loop
			return "$result" # found, so break out of for loop
		else 
			result=1
		fi
	done

	return "$result" # returns 1 for failing to find a match

}
##########################################################################################################

echo
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo "STARTING THE 'WRITE SOURCE MEDIA FILENAMES TO THE STORAGE LOCATION' PHASE"
echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
echo

# remove previous output files during development
# in service we could either create another subdirectory, continue to delete, keep one or two previous copies or....
# no risk of sync conflicts, as date augmented filenames mean completely different files
# 
rm "${destination_holding_dir_fullpath}"/*

for source_input_dir_fullpath in "${source_holding_dir_fullpath}"/*
do
	# TODO: really? ignore files in the source_holding_dir_fullpath? really? yes for now.
	if ! [[ -d "$source_input_dir_fullpath" ]]
	then
		echo "NOT A DIRECTORY ::::::::::::     "$source_input_dir_fullpath""
		continue
	fi

	# find out if the current source_input_dir_fullpath is configured to be ignored, if so we can skip to the next
	test_for_ignore_dir "$source_input_dir_fullpath" 
	return_code=$?; echo "return_code : $return_code"
	if [[ "$return_code" -eq 0 ]]
	then
		echo "IGNORING ::::::::::::     "$source_input_dir_fullpath""
		continue
	fi

	# from HERE on we can assume that we're OK TO GO to audit source_input_dir_fullpath...
	# also, try [[:alphanum:]] or [A-Za-z0-9_-]


	# we need this in order to name the output file 
	source_input_dir_name="${source_input_dir_fullpath##*'/'}"	

	destination_output_file_name="${source_input_dir_name}.$(date +'%F@%T')" # use an augmented input directory name to name the output file

	destination_output_file_fullpath="${destination_holding_dir_fullpath}/${destination_output_file_name}"

	# NOW THAT WE HAVE A $destination_output_file_fullpath WE CAN FIND OUT WHETHER IT NEEDS ENCRYPING (AND SO ADDED TO THE ... ARRAY)
	# BY TESTING THE IF THE CORRESPONDING $source_input_dir_fullpath IS SECRET. WE'LL CALL A FUNCTION TO LOOP THROUGH THE secret_content_directories ARRAY:
	
	# IF SO, WE ADD $destination_output_file_fullpath TO AN ... ARRAY THAT WILL BE SENT OVER WHEN encryption_services
	# IS CALLED ONCE AT THE END

	test_for_secret_dir "$source_input_dir_fullpath" 
	return_code=$?; echo "return_code : $return_code"
	if [[ "$return_code" -eq 0 ]]
	then
		# NOW APPEND THE ARRAY
		echo "APPENDING ARRAY  ::::::::::::  WITH $destination_output_file_fullpath   "
		file_fullpaths_to_encrypt+=( "${destination_output_file_fullpath}" )
	fi


	echo "destination_output_file_fullpath set to : $destination_output_file_fullpath" # debug

	printf "filename: %s\t" $destination_output_file_fullpath >> "$destination_output_file_fullpath"
	printf "%s\n" "::  $(date +"	[%Y-%m-%d] [%H:%M:%S]")" >> "$destination_output_file_fullpath"
	printf "%s\n" "@@@@@@@audit@@@@@@@@@@@@@@@@@@@ :: $destination_output_file_fullpath :: @@@@@@@@@@@output@@@@@@@@@@@@@@@" >> "$destination_output_file_fullpath"
	printf "%s\n" "   @@@@@@@  ::  $(date +"	[%Y-%m-%d] [%H:%M:%S]") ::     @@@@@@@    " >> "$destination_output_file_fullpath"


	# output file created for appended redirect, any problem tell the hand
	# TODO: better to use `find` and specify a list of file extensions of interest - investigate later
	echo >> "$destination_output_file_fullpath" # empty lines for format
	echo >> "$destination_output_file_fullpath"

	ls -R "$source_input_dir_fullpath" >> "$destination_output_file_fullpath"  2>/dev/null # suppress stderr


	## TODO: WE JUST WANT THE COUNT HERE, SO REDIRECT OR PIPE TO sed || USE VARIABLE EXPANSION ON A VARIABLE
	echo "LINE COUNT OUTPUT FOR FILE: `wc -l "$destination_output_file_fullpath"` "

	echo
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	echo "       END WRITE 'FOR' LOOP FOR ONE SOURCE DIRECTORY... NEXT ..."
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	echo


	#which encryption_services

	#read

	#encryption_services 

	# find out `if` the current source_input_dir_fullpath is configured to be secret, meaning that the current destination_output_file_fullpath
	# is to be encrypted and replaced. if so, call on those services:

	# we want to replace destination_output_file_fullpath with an encrypted version.
	# we test for the existence of a known service (using `which encryption_services`)
	# we call encryption_services, passing it the following parameters:
	# - the file to be encrypted: destination_output_file_fullpath
	# - 
	# when encrypton_services returns control, we test whether the results are as expected before confirming success to user.
	# we shred the plain text version of the file(s) - simple test `type`|`file`
	#


done	


which encryption_services
echo "OUR CURRENT SHELL LEVEL IS: $SHLVL"

read


for filename in "${file_fullpaths_to_encrypt[@]}"
do
	echo "888888888888888888888888888888888888888888888888888888888888888888"
	string_to_send+="${filename} " # with a trailing space character after each
done

# now to trim that last trailing space character:
string_to_send=${string_to_send%[[:blank:]]}

echo "${string_to_send}"

#exit 0

## deliberately unquoted, so arguments are separated by spaces (trim trailing sp)
encryption_services $string_to_send

# NOW TO PASS THE ARRAY CONTAINING THE FILE(S) TO BE ENCRYPTED
# BASH ARRAYS ARE NOT 'FIRST CLASS VALUES' SO CAN'T PASS AROUND LIKE ONE THING 
#encryption_services "${file_fullpaths_to_encrypt[@]}"

#test_for_hash_match_ARRAYS hash_test_batch_array[@]

##########################################################################################################
##########################################################################################################

echo "exit code: $?" && exit 



