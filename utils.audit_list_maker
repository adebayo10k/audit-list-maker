#!/bin/bash
#: Title		:utils.audit_list_maker
#: Date			:2019-07-05
#: Author		:adebayo10k
#: Version		:1.0
#: Description	:create independently stored reference listings of the media files
#: Description	:on a drive when the backup of those files is not really justified.
#: Description	:backup reacquire recreate 
#: Options		:
##
echo "USAGE: $(basename $0) <PROD|DEV>"  
## at command line:~# 
##
#######################################################################

# Except when called by a launcher script this script is the sole entry point into program,
# and thus the parent process - so we set any environment variables here.

#######################################################################

# SET PROGRAM RUN MODE:
# passed in from command line, this is set to:
# DEV during developemnt. We work on controlled, sample configuration and input data
# PROD when working on real data using real configuration settings
RUN_MODE=$1 
export RUN_MODE

#######################################################################

## EXIT CODES:
E_UNEXPECTED_BRANCH_ENTERED=10
E_OUT_OF_BOUNDS_BRANCH_ENTERED=11
E_INCORRECT_NUMBER_OF_ARGS=12
E_UNEXPECTED_ARG_VALUE=13
E_REQUIRED_FILE_NOT_FOUND=20
E_UNKNOWN_RUN_MODE=30
E_UNKNOWN_EXECUTION_MODE=31

export E_UNEXPECTED_BRANCH_ENTERED
export E_OUT_OF_BOUNDS_BRANCH_ENTERED
export E_INCORRECT_NUMBER_OF_ARGS
export E_UNEXPECTED_ARG_VALUE
export E_REQUIRED_FILE_NOT_FOUND
export E_UNKNOWN_RUN_MODE
export E_UNKNOWN_EXECUTION_MODE

#######################################################################

# GLOBAL VARIABLE DECLARATIONS:
line_type="" # global...
source_directory="" # global...
test_line="" # global...

#test_dir="" # need to be global?

# explicitly declaring variables to make code bit more robust - move to top
audit_list_storage_directory="" # single directory in which....
source_directory="" # single directory from which....
declare -a directories_to_ignore=() # set of one or more directories...
declare -a secret_content_directories=() # set of one or more directories...



#######################################################################

# TEST COMMAND LINE ARGS
if [ $# -ne 1 ]
then
	echo "Incorrect number of command line args. Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit $E_INCORRECT_NUMBER_OF_ARGS
fi

# if ! [[ "${1}" = 'DEV' -o "${1}" = 'PROD' ]]
if ! [[ "${1}" = 'DEV' || "${1}" = 'PROD' ]] 
then
	echo "Incorrect command line arg.  Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit $E_UNEXPECTED_ARG_VALUE
fi

#######################################################################

# SET THE SCRIPT ROOT DIRECTORY IN WHICH THIS SCRIPT CURRENTLY FINDS ITSELF
# 
echo "Full path to this script: $0" && echo

## remove from end of full path: a directory delimiter and the basename
script_root_dir="${0%'/'"$(basename $0)"}"
echo "Script root directory set to: $script_root_dir"
export script_root_dir

echo;echo

#######################################################################
# USED GENERALLY TO TEST EXISTENCE AND ACCESSIBILITY OF A DIRECTORY
function test_directory_accessible
{
echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	test_dir="$1"

	if [ -d "$test_dir" ] && cd "$test_dir" 2>/dev/null
	then
		# directory file found and accessible
		echo "directory "$test_dir" found and accessed ok" && echo
	else
		# -> exit due to failure of any of the above tests:
		echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
		exit $E_REQUIRED_FILE_NOT_FOUND
	fi

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

#######################################################################

# SET PATH TO CONFIGURATION FILE:
# set a default location for the config file
# during development we'll put:
# - an untracked development version outside $script_root_dir (perhaps in it's parent dir)
# - a tracked sanitised version in $script_root_dir
# during service we'll put the config file in an /etc directory:
# 
# config PII sanitiser script located outside $script_root_dir ?

config_file_basename=audit_config
echo "Our configuration filename is set to: $config_file_basename" && echo

## full path to the directory in which the configuration file is located.
# ad-hoc to keep our stuff hidden for now. Later hope to just hard code this.
config_file_root_dir="$(cd $script_root_dir; cd ../; pwd)" ## returns with no trailing /
echo "Our configuration file sits in: $config_file_root_dir" && echo

full_path_to_config_file="${config_file_root_dir}/${config_file_basename}"
echo "The full path to our configuration file is: $full_path_to_config_file" && echo

# TEST THAT CONFIGURATION FILE EXISTS IN THE DEFAULT LOCATION AND IS ACCESSIBLE.
test_directory_accessible "$config_file_root_dir"

if [ -f "$full_path_to_config_file" ]
then
	# configuration file found and accessible
	echo "Configuration file found ok" && echo
else
	# -> exit due to failure of any of the above tests:
	echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
	exit $E_REQUIRED_FILE_NOT_FOUND
fi

##########################################################################################################
# TESTS WHETHER THE LINE IS OF EITHER VALID comment, empty/blank OR string (variable or value) TYPE,
# SETS THE GLOBAL line_type AND test_line variableS.
function test_and_set_line_type
{

#echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	# TODO: ADD ANOTHER CONFIG FILE VALIDATION TEST:
	# TEST THAT THE LINE FOLLOWING A VARIABLE= ALPHANUM STRING MUST BE A VALUE/ ALPHANUM STRING, ELSE FAIL
	test_line="${1}"
	line_type=""

	#debug printouts:
	#echo "$test_line"

	if [[ "$test_line" == "#"* ]] # line is a comment
	then
		line_type="comment"
		#echo "line_type set to: $line_type"
	elif [[ "$test_line" =~ [[:blank:]] || "$test_line" == "" ]] # line empty or contains only spaces or tab characters
	then
		line_type="empty"
		#echo "line_type set to: $line_type"
	elif [[ "$test_line" =~ [[:alnum:]] ]] # line is a string (not commented)
	then
		echo -n "Alphanumeric string  :  "
		if [[ "$test_line" == *"=" ]]
		then
			line_type="variable_string"
			echo "line_type set to: "$line_type" for "$test_line""
		elif [[ "$test_line" =~ ^.*/.*$ ]]	# match the file path pattern TODO: find a better regex
		then
			line_type="value_string"
			echo "line_type set to: "$line_type" for "$test_line""
		else
			echo "Failsafe : Couldn't match the Alphanum string"
			echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
			exit $E_UNEXPECTED_BRANCH_ENTERED
		fi

	else
		echo "Failsafe : Couldn't match this line with ANY line type!"
		echo "Exiting from function ${FUNCNAME[0]} in script $(basename $0)"
		exit $E_UNEXPECTED_BRANCH_ENTERED
	fi

#echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################

# TEST WHETHER THE CONFIGURATION FILE FORMAT IS VALID
while read lineIn
do
	test_and_set_line_type "$lineIn" 

done < "$full_path_to_config_file" 

echo "exit code after line tests: $?" && echo

## if $? -eq 0 ...

# if tests passed, configuration file is accepted and used from here on
echo "we can use this configuration file" && echo
export config_file_basename
export config_file_root_dir
export full_path_to_config_file

##########################################################################################################
##########################################################################################################
# FINAL OPERATION ON VALUE, SO GLOBAL test_line SET HERE. RENAME CONCEPTUALLY DIFFERENT test_line NAMESAKES
function sanitise_absolute_path_value ##
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	# sanitise values
	# - trim leading and trailing space characters
	# - trim trailing / for all paths
	test_line="${1}"
	echo "test line on entering "${FUNCNAME[0]}" is: $test_line" && echo

	# TRIM TRAILING AND LEADING SPACES AND TABS
	test_line=${test_line%%[[:blank:]]}
	test_line=${test_line##[[:blank:]]}

	# TRIM TRAILING / FOR ABSOLUTE PATHS:
	test_line=${test_line%'/'}
	#test_line=${test_line%\/}

	echo "test line after trim cleanups in "${FUNCNAME[0]}" is: $test_line" && echo

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}


##########################################################################################################
# FINAL OPERATION ON VALUE, SO GLOBAL test_line SET HERE...
function sanitise_relative_path_value
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	# sanitise values
	# - trim leading and trailing space characters
	# - trim leading / for relative paths
	# - trim trailing / for all paths
	test_line="${1}"
	echo "test line on entering "${FUNCNAME[0]}" is: $test_line" && echo

	# TRIM TRAILING AND LEADING SPACES AND TABS
	test_line=${test_line%%[[:blank:]]}
	test_line=${test_line##[[:blank:]]}

	# TRIM LEADING AND TRAILING / FOR RELATIVE PATHS:
	test_line=${test_line%'/'}
	#test_line=${test_line%\/}
	test_line=${test_line##'/'}
	#test_line=${test_line##\/}

	echo "test line after trim cleanups in "${FUNCNAME[0]}" is: $test_line" && echo

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################
##########################################################################################################
## VARIABLE 1:
# TODO: LATER - COULD THESE TWO FUNCTIONS FOR VARIABLES 1 AND 2 BE CONSOLIDATED INTO ONE FOR ABSOLUTED PATH VALUES?
# ...WITH A keyword ARRAY FOR LOOPED THOUGH?
function get_audit_list_storage_directory_config
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	keyword="audit_list_storage_directory="
	line_type=""
	value_collection="OFF"

	while read lineIn
	do

		test_and_set_line_type "$lineIn" # interesting for the line FOLLOWING that keyword find

		if [[ $value_collection == "ON" && $line_type == "value_string" ]]
		then
			sanitise_absolute_path_value "$lineIn"
			echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
			echo "test_line has the value: $test_line"
			echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
			set -- $test_line # using 'set' to get test_line out of this subprocess into a positional parameter ($1)

		elif [[ $value_collection == "ON" && $line_type != "value_string" ]] # last value has been collected for audit_list_storage_directory
		then
			value_collection="OFF" # just because..
			break # end this while loop, as last value has been collected for audit_list_storage_directory
		else
			# value collection must be OFF
			:
		fi
		
		
		# switch value collection ON for the NEXT line read
		if [[ "$lineIn" == "$keyword" ]]
		then
			value_collection="ON"
		fi

	done < "$full_path_to_config_file"

	# ASSIGN
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	echo "test_line has the value: $1"
	echo "audit_list_storage_directory has the value: $audit_list_storage_directory"
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"

	audit_list_storage_directory="$1" # test_line just set globally in sanitise_absolute_path_value function
	set -- # unset that positional parameter we used to get test_line out of that while read subprocess
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
	echo "test_line (AFTER set --) has the value: $1"
	echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"


echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################
## VARIABLE 2:
function get_source_directory_config
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	keyword="source_directory="
	## ACCESS TO RELATIVE DIRECTORIES CAN ONLY BE TESTED ONCE source_directory
	# HAS BEEN TESTED OK AND VARIABLE ASSIGNED
	line_type=""
	value_collection="OFF"

	while read lineIn
	do

		test_and_set_line_type "$lineIn" # interesting for the line FOLLOWING that keyword find

		if [[ $value_collection == "ON" && $line_type == "value_string" ]]
		then
			sanitise_absolute_path_value "$lineIn"
			set -- $test_line # 

		elif [[ $value_collection == "ON" && $line_type != "value_string" ]] # last value has been collected for audit_list_storage_directory
		then
			value_collection="OFF" # just because..
			break # end this while loop, as last value has been collected for audit_list_storage_directory
		else
			# value collection must be OFF
			:
		fi
		
		
		# switch value collection ON for the NEXT line read
		if [[ "$lineIn" == "$keyword" ]]
		then
			value_collection="ON"
		fi

	done < "$full_path_to_config_file"


	# ASSIGN 
	source_directory=$1 # test_line was just set globally in sanitise_absolute_path_value function
	set -- # unset that positional parameter we used to get test_line out of that while read subprocess

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################
## VARIABLE 3:
function get_directories_to_ignore_config
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	keyword="directories_to_ignore="

	# NOW MULTIPLE LINE VALUES ASSIGNED TO ARRAY ELEMENT, SO BIT DIFFERENCE LOGIC
	line_type=""
	value_collection="OFF"
	# unset path_list?
	declare -a path_list=() # local array to store one or more sanitised relative paths

	while read lineIn
	do

		test_and_set_line_type "$lineIn" # interesting for the line FOLLOWING that keyword find

		if [[ "$value_collection" == "ON" && "$line_type" == "value_string" ]]
		then
			
			sanitise_relative_path_value "$lineIn"
			path_list+=("${test_line}")
			# Not sure why we CAN access test_line here, when we had to use 'set' in the other functions?!?
			# Seems to work ok, so no complaining.
			
		elif [[ "$value_collection" == "ON" && "$line_type" != "value_string" ]] # last value has been collected for ...
		then
			
			value_collection="OFF" # just because..
			break # end this while loop, as last value has been collected for ....y
		else
			# value collection must be OFF
			:
		fi
		
		
		# switch value collection ON for the NEXT line read
		if [[ "$lineIn" == "$keyword" ]]
		then
			value_collection="ON"
		fi
		
	done < "$full_path_to_config_file"

	## debug7..
	echo && echo "The values in the path_list array just before it's cloned by the directories_to_ignore array:"
	for value in "${path_list[@]}"
	do
		echo -n "$value "

	done

	# ASSIGN THE LOCAL ARRAY BY CLONING
	directories_to_ignore=("${path_list[@]}")

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################
## VARIABLE 4:
function get_secret_content_directories_config
{

echo && echo "Entered into function ${FUNCNAME[0]}" && echo

	keyword="secret_content_directories="

	# NOW MULTIPLE LINE VALUES ASSIGNED TO ARRAY ELEMENT, SO BIT DIFFERENCE LOGIC
	line_type=""
	value_collection="OFF"
	declare -a path_list=() # local array to store one or more sanitised relative paths

	while read lineIn
	do

		test_and_set_line_type "$lineIn" # interesting for the line FOLLOWING that keyword find

		if [[ $value_collection == "ON" && $line_type == "value_string" ]]
		then
			sanitise_relative_path_value "$lineIn"
			path_list+=( "${test_line}" )
			# Not sure why we CAN access test_line here, when we had to use 'set' in the other functions?!?
			# Seems to work ok, so no complaining.

		elif [[ $value_collection == "ON" && $line_type != "value_string" ]] # last value has been collected for ...
		then
			value_collection="OFF" # just because..
			break # end this while loop, as last value has been collected for ...
		else
			# value collection must be OFF
			:
		fi
		
		
		# switch value collection ON for the NEXT line read
		if [[ "$lineIn" == "$keyword" ]]
		then
			value_collection="ON"
		fi

	done < "$full_path_to_config_file"

	# ASSIGN THE LOCAL ARRAY BY CLONING
	secret_content_directories=("${path_list[@]}")

echo && echo "Leaving from function ${FUNCNAME[0]}" && echo

}

##########################################################################################################

# IMPORT CONFIGURATION INTO VARIABLES

#TODO: ALL THESE CAN BE DONE IN ONE FUNCTION LATER?, BUT KEEP IT SIMPLE FOR NOW
# SINGLE FUNCTION WOULD STORE EACH keyword IN AN ARRAY, WHICH WE'D LOOP THROUGH FOR EACH LINE READ
get_audit_list_storage_directory_config
get_source_directory_config
get_directories_to_ignore_config
get_secret_content_directories_config

# NOW DO ALL THE DIRECTORY ACCESS TESTS FOR IMPORTED PATH VALUES HERE.
# REMEMBER THAT ORDER IMPORTANT, AS RELATIVE PATHS DEPEND ON ABSOLUTE.
# debug printouts:
echo
echo "FINALLY, audit_list_storage_directory variable now set to: $audit_list_storage_directory" && echo
test_directory_accessible "${audit_list_storage_directory}"

echo "FINALLY, source_directory variable now set to: $source_directory" && echo
test_directory_accessible "$source_directory"

for dir_path in "${directories_to_ignore[@]}"
do
	echo -n "FINALLY, directories_to_ignore list ITEM now set to:"
	echo "$dir_path"
	test_directory_accessible "${source_directory}/$dir_path"
done

echo

for dir_path in "${secret_content_directories[@]}"
do
	echo -n "FINALLY, secret_content_directories list ITEM now set to:"
	echo "$dir_path"
	test_directory_accessible "${source_directory}/$dir_path"
done

##########################################################################################################
#################################
# TODO:
# 0. CREATE 'TEST' SOURCE AND DESTINATION DIRECTORIES THAT DON'T CONTAIN TOO MUCH CONTENT.
#    REFLECT THESE IN A TEST CONFIGURATION FILE.
# 	 REMEMBER, ABSOLUTE PATHS WILL REVEAL PII, SO KEEP IN UNTRACKED PLACES.
# 1. CONTINUE DEVELOPMENT WITH THESE UNTRACKED CONFIG FILES.
# 2. WHEN ALL BASIC FUNCTIONALITY IS TESTED AND WORKING, CREATE THE USER OPTION FUNCTIONS
#    TO SELECT WHICH CONFIG FILE TO USE. DEFAULT TO /etc/<project_name>
# 3. EVEN DURING SERVICE, CONFIG FILES ARE LIKELY TO BE IN UNTRACKED PLACE LIKE /etc , SO 
#    BEST SOLUTION TO SHARING A SAMPLE CONFIG MAY BE TO ADD A LINE IN THE LAUNCHER SCRIPT
# 	 THAT CALLS A GENERAL PURPOSE (IF POSSIBLE) SANITISER SCRIPT.


#################################

# WRITE SOURCE MEDIA FILENAMES TO THE STORAGE LOCATION
# the designated storage directory must already exist - it won't be created by this script.




#################################

echo "exit code: $?" && exit 



