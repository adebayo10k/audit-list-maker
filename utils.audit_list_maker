#!/bin/bash
#: Title		:utils.audit_list_maker
#: Date			:2019-07-05
#: Author		:adebayo10k
#: Version		:1.0
#: Description	:create independently stored reference listings of the media files
#: Description	:on a drive when the backup of those files is not really justified.
#: Description	:backup reacquire recreate 
#: Options		:
##
echo "USAGE: $(basename $0) <PROD|DEV>"  
## at command line:~# 
##
#######################################################################

# Except when called by a launcher script this script is the sole entry point into program,
# and thus the parent process - so we set any environment variables here.

## EXIT CODES:
E_UNEXPECTED_BRANCH_ENTERED=10
E_OUT_OF_BOUNDS_BRANCH_ENTERED=11
E_INCORRECT_NUMBER_OF_ARGS=12
E_UNEXPECTED_ARG_VALUE=13
E_REQUIRED_FILE_NOT_FOUND=20
E_UNKNOWN_RUN_MODE=30
E_UNKNOWN_EXECUTION_MODE=31

export E_UNEXPECTED_BRANCH_ENTERED
export E_OUT_OF_BOUNDS_BRANCH_ENTERED
export E_INCORRECT_NUMBER_OF_ARGS
export E_UNEXPECTED_ARG_VALUE
export E_REQUIRED_FILE_NOT_FOUND
export E_UNKNOWN_RUN_MODE
export E_UNKNOWN_EXECUTION_MODE

#################################

# TEST COMMAND LINE ARGS
if [ $# -ne 1 ]
then
	echo "Incorrect number of command line args. Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit E_INCORRECT_NUMBER_OF_ARGS
fi

# if ! [[ "${1}" = 'DEV' -o "${1}" = 'PROD' ]]
if ! [[ "${1}" = 'DEV' || "${1}" = 'PROD' ]] 
then
	echo "Incorrect command line arg.  Exiting now..."
	echo "Usage: $(basename $0) <PROD|DEV>"
	exit E_UNEXPECTED_ARG_VALUE
fi

#################################

# SET PROGRAM RUN MODE:
# passed in from command line, this is set to:
# DEV during developemnt. We work on controlled, sample configuration and input data
# PROD when working on real data using real configuration settings
RUN_MODE=$1 
export RUN_MODE

#################################

## TODO: THIS will have to be a relative path, once all
## directories including the one in which THIS script is put (bin, usr/local/bin)
## have been specified, exported and globally known.
## AND REMEMBER TO SANITISE CODE


# TEST: change the following to handle changed file path format:
# file paths to conform to unix standard:
# no leading / for relative paths
# trailing / for directories
# 
echo "Full path to this script: $0" && echo

## remove from end of full path: a directory delimiter and the basename
echo "Current base directory of this script: ${0%'/'"$(basename $0)"}" 
script_root_dir="${0%'/'"$(basename $0)"}"
echo "Script root directory set to: $script_root_dir"
export script_root_dir

echo;echo

## remove from end of full path: just the basename, leaving trailing /
echo "Current base directory of this script: ${0%"$(basename $0)"}" 
script_root_dir="${0%"$(basename $0)"}"
echo "Script root directory set to: $script_root_dir" && echo

export script_root_dir

#################################

# SET PATH TO CONFIGURATION FILE:
# set a default location for the config file
# during development we'll put:
# - an untracked development version outside $script_root_dir (perhaps in it's parent dir)
# - a tracked sanitised version in $script_root_dir
# during service we'll put the config file in an /etc directory:
# 
# config sanitiser script located outside $script_root_dir ?

# test for valid file format, else fail
# export path to config file

config_file_basename=audit_config
echo "Our configuration filename is set to: $config_file_basename" && echo

## full path to the directory in which the configuration file is located.
# ad-hoc to keep our stuff hidden for now. Later hope to just hard code this.
config_file_root_dir="$(cd $script_root_dir; cd ../; pwd)" ## returns with no trailing /
echo "Our configuration file sits in: $config_file_root_dir" && echo

full_path_to_config_file="${config_file_root_dir}/${config_file_basename}"
echo "The full path to our configuration file is: $full_path_to_config_file" && echo

# TEST THAT CONFIGURATION FILE EXISTS IN THE DEFAULT LOCATION AND IS ACCESSIBLE.
# testing 'all in one' for now assuming no part will fail
if [ -d "$config_file_root_dir" ] && cd "$config_file_root_dir" 2>/dev/null && [ -f "$full_path_to_config_file" ] # 2>/dev/null" hides error message
then
	# configuration file found and accessible
	echo "Configuration file found ok" && echo
	else
	# -> exit due to failure of any of the above tests:
	echo "Exiting from function "${FUNCNAME}" in script $(basename $0)"
	exit E_REQUIRED_FILE_NOT_FOUND
fi

##########################################################################################################

function test_line_content_valid
# test that the line is either a comment, empty/blank or string of valid format
{
line="${1}"

if [[ "$line" == "#"* ]] # line is a comment
then
	echo "This line was found to be a comment:"
	#echo "$line"
elif [[ "$line" =~ [[:blank:]] || "$line" == "" ]] # line empty or contains only spaces or tab characters
then
	echo "Blank line"
elif [[ "$line" =~ [[:alnum:]] ]] # line is a string (not commented)
then

	echo -n "Alphanumeric string  :  "
	if [[ "$line" == *"=" ]]
	then
		echo "Variable Alpha string="
	##  	
	elif [[ "$line" =~ ^.*/.*$ ]]	# match the file path pattern TODO: find a better regex
	then
		echo "Value Alpha string/"
	else
		echo "Failsafe : Couldn't match the Alphanum string"
		exit 1
	fi

else
	echo "None of the above"
	exit 1
fi

}

##########################################################################################################

# TEST THAT CONFIGURATION FILE FORMAT IS VALID
while read lineIn
do

	test_line_content_valid "$lineIn" 

done < "$full_path_to_config_file" 

echo "exit code after line tests: $?" && echo

## if $? -eq 0 ...

echo "we can use this configuration file"
export config_file_basename
export config_file_root_dir
export full_path_to_config_file

#################################

echo "exit code: $?" && exit 



